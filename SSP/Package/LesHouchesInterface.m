(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



  (* ---------------------------------------------------------------------- *)
(* Routines for Reading SLHA files and writing input files for SPheno;   *)
(* ---------------------------------------------------------------------  *)

(* by Florian Staub, Last change: 27.08.2010 *)

(*

Reading Files: ReadSpectrumFile["Filename"];


--------------------------------------------------------------------------------;

Show value: ShowValue[Blockname,Entry,Options]; 
Blockname is a Mathematica symbol, not a String; Entry can be a integer or a list of integers; 
Options: Appearance: Shows the value for the x. appearance of the parameter in the files. Default is the Last one;

Examples:

ShowValue[Yd,{1,1}];
ShowValue[Mass,25];
ShowValue[Gauge,1,Appearance->1]; 

Decay and branching ratios:

ShowWidth[PDG of decaying particle];
ShowWidth[PDG of decaying particle,{PDGs of final states}];

--------------------------------------------------------------------------------;

Show complete Block: ShowBlock[Blockname, Options];
Some usage as ShowValue;

--------------------------------------------------------------------------------;


Write input File for SPheno;

WriteLesHouchesIn[MINPAR,Options];

MINPAR: List of parameters which are written in the Block MINPAR;
Options: 
   MODSEL: Entries of Block MODSEL, Default: {{1,1}};
   AddBlocks: Additional Block which should be written to the file. First the Blockname is given, afterwards the entries.;

Examples:

WriteLesHouchesIn[{80,250,1000,10,1}];
WriteLesHouchesIn[{80,250,1000,10,1}, MODSEL->{{1,1},{3,11},{6,1}}];
WriteLesHouchesIn[{80,250,1000,10,1},AddBlocks -> {{YBIN,{1,1,0.5},{2,2,0.5},{3,3,0.6}},{YTIN,{1,1,0.1},{2,2,0.2},{3,3,0.3}}}];

*)








Off[General::spell];


ReadSpectrumFile[file_,split_]:=ReadSpectrumFileFunc[file,split,False,{},"no.dat",MachinePrecision,0];
ReadSpectrumFileFunc[file_,splitsequence_,subset_,subblocks_,outputfile_,precision_,chop_]:=Block[{i,j,a,b,c,sps={}, temp,t="", return,subfile,SplitLine,in,decay},
If[FileExistsQ[file]==False,
File::DoesntExist="File `` does not exist";
Message[File::DoesntExist,file];
Interrupt[];
];
If[splitsequence=!=False,
AllLesHouchesInput={};
SplitLine =splitsequence;,
SplitLine="123NO!";
];
If[subset===True && outputfile=!=None,
subfile=OpenWrite[outputfile];
WriteString[subfile,"{ \n"];
];
in=OpenRead[file];
While[t=!="BLOCK" && t=!="DECAY", t=ToUpperCase[Read[in,Word]]; ];
return=t;
While[return=!=EndOfFile, 
If[ToUpperCase[return]==="BLOCK",
temp=ReadBlock[False,SplitLine,precision,chop];
decay=False;,
temp=ReadBlock[True,SplitLine,precision,chop];
decay=True;
];
return=temp[[2]];
If[decay==True, temp[[1]]=SortDecay[temp[[1]]];];
If[subset=!=True,
sps=Join[sps,{temp[[1]]}];,
If[FreeQ[subblocks,ToExpression[temp[[1,1]]]]==False,
sps=Join[sps,{temp[[1]]}];
];
];

If[splitsequence=!=False,
If[return===splitsequence,
If[subset=!=True,
AllLesHouchesInput=Join[AllLesHouchesInput,{sps}];,
If[outputfile===None,
AllLesHouchesInput=Join[AllLesHouchesInput,{sps}];,
WriteString[subfile,ToString[InputForm[sps]]<>", \n"];
];
];
t="";
While[t=!="BLOCK" && t=!="DECAY" && t=!=ToUpperCase[EndOfFile], t=ToUpperCase[Read[in,Word]]; ];
If[t===ToUpperCase[EndOfFile],
return=EndOfFile;,
return=t;
];
sps={};
];
];
];
Close[in];
If[subset=!=True,
If[splitsequence=!=False,
AllLesHouchesInput=Join[AllLesHouchesInput,{sps}];
];
LesHouchesInput=sps;,
If[outputfile=!=None,
WriteString[subfile,"{}} \n"];
Close[subfile];
];
]; (* Print["Finished with reading!"]; *)
];

SortDecay[list_]:=Block[{temp={},temp1={},i},
temp1=DeleteCases[list,{},3];
temp={temp1[[1]],{WIDTH,width}};
For[i=2,i<=Length[temp1],
temp=Join[temp,{{FinalParticles@@Take[temp1[[i]],{3,Length[temp1[[i]]]}],temp1[[i,1]]}}];
i++;];
Return[temp];
];

ReadBlock[decay_,SplitLine_,precision_,chop_]:=Block[{i,t,temp,temp1={},j,test,first=True},
temp ={ToUpperCase[Read[in,Word]]};
SetStreamPosition[in,StreamPosition[in]-1];
test=Read[in,String];
If[decay==True,
width=StringDrop[test,1];
width = RoundWithPrecision[ToExpression[StringReplace[StringTake[width,{1,StringPosition[width,"#"][[1,1]]-1}],{"E"->"*10^","e"->"*10^"}]],precision,chop];
];
While[ToUpperCase[j]=!="BLOCK" && ToUpperCase[j]=!="DECAY" &&ToUpperCase[j]=!= SplitLine&& j=!=EndOfFile,
i=j;
If[i==="#",
temp = Join[temp,{temp1}];
SetStreamPosition[in,StreamPosition[in]-1];
test=Read[in,String];
temp1={};,
If[first=!=True &&  ToUpperCase[j]=!="DECAY", temp1 = Join[temp1,{RoundWithPrecision[ToExpression[StringReplace[i,{"E"->"*10^","e"->"*10^"}]],precision,chop]}]; ];
];
j=Read[in,Word];
first=False;
];
If[temp[[1]]==="HIGGSBOUNDSINPUTHIGGSCOUPLINGSFERMIONS",
temp=temp /. {a_,b_,3,e_,f_,g_}->{e,f,g,{a,b}};,
If[temp[[1]]==="HIGGSBOUNDSINPUTHIGGSCOUPLINGSBOSONS",
temp=temp /. {a_,3,e_,f_,g_}->{e,f,g,a}/. {a_,4,e_,f_,g_,h_}->{e,f,g,h,a};
];
];
Return[{temp,j}];
];

SetAttributes[FinalParticles,Orderless];

RoundWithPrecision[number_,precision_,chop_]:=Block[{res},
If[NumericQ[precision]==False || precision ===MachinePrecision || Head[number]=!=Real || number==0. ,
Return[number];,
If[Abs[number]<chop,Return[0.];,
res=  Round[ number/(10^Floor[Log[10,Abs[number]]])*(10^(precision-1))]/(10^(precision-1));
Return[N[res*(10^Floor[Log[10,Abs[number]]])]];
];
];
];



FindValue[block_,entry_,data_,app_]:=Block[{pos,blockname},
If[Head[block]===Symbol,
blockname=ToUpperCase[ToString[block]];,
blockname = ToUpperCase[block];
];

pos=Position[data,blockname];
If[pos=!={},
If[Head[app]===Integer,
pos = pos[[app,1]];,
pos=Last[pos][[1]];
];
temp=DeleteCases[Drop[Extract[data,pos],1],{}];
If[entry===None, Return[temp];];
If[Head[entry]===List,
pos=Cases[NIX[temp][[1]],Join[entry,{_}]];
If[pos=={},Return[None];];
Return[Last[pos[[1]]]];,
pos=Position[Transpose[temp][[1]],entry];
If[pos=={},Return[None];];
Return[temp[[pos[[1,1]]]][[2]]];
];,
Return[None];
];
];



Options[ShowValue]={Appearance->Last};
Options[ShowBlock]={Appearance->Last};
Options[ShowBR]={Appearance->Last};

ShowValue[block_,entry_,opt___]:=FindValue[ToUpperCase[ToString[block]],entry,LesHouchesInput,Appearance/.{opt}/.Options[ShowValue]];
ShowBlock[block_,opt___]:=FindValue[ToUpperCase[ToString[block]],None,LesHouchesInput,Appearance/.{opt}/.Options[ShowBlock]];
ShowWidth[block_]:=FindValue[ToUpperCase[ToString[block]],WIDTH,LesHouchesInput,Last];
ShowBR[field_,particles_]:=FindValue[ToUpperCase[ToString[field]],FinalParticles@@particles,LesHouchesInput,Last];


Options[WriteLesHouchesIn]:={MODSEL->{{1,1}},AddBlocks->{}};

WriteLesHouchesIn[MINPAR_,opt___]:=WriteLesHouchesInFunc[MINPAR,MODSEL /. {opt} /.Options[WriteLesHouchesIn],AddBlocks /. {opt} /.Options[WriteLesHouchesIn]];

WriteLesHouchesInFunc[MINPAR_,MODSEL_,AddBlocks_]:=Block[{i},
lh = OpenWrite["LesHouches.in"];
WriteString[lh,"Block MODSEL # \n"];

For[i=1,i<=Length[MODSEL],
WriteString[lh,ToString[MODSEL[[i,1]]]<>"  "<>ToString[MODSEL[[i,2]]]<>" #\n"];
i++;];

WriteString[lh,"Block SMINPUTS # Standard Model inputs\n"];
WriteString[lh,"2 1.166390E-05 # G_F,Fermi constant\n"];
WriteString[lh,"3 1.172000E-01 # alpha_s(MZ) SM MSbar\n"];
WriteString[lh,"4 9.118760E+01 # Z-boson pole mass\n"];
WriteString[lh,"5 4.214000E+00 # m_b(mb) SM MSbar\n"];
WriteString[lh,"6 1.714000E+02 # m_top(pole)\n"];
WriteString[lh,"7 1.777000E+00 # m_tau(pole)\n"];

WriteString[lh,"Block MINPAR # Input parameters\n"];
For[i=1,i<=Length[MINPAR],
WriteString[lh,ToString[i]<>" \t "<> ToString[FortranForm[MINPAR[[i]]]]<>"\t # \n"];
i++;];

For[i=1,i<=Length[AddBlocks],
WriteString[lh,"Block "<>ToString[AddBlocks[[i,1]]]<>" # \n"];
For[j=2,j<=Length[AddBlocks[[i]]],
WriteString[lh,StringReplace[ToString[Drop[AddBlocks[[i,j]],-1]],{","->"\t","{"->"","}"->""}]<>" \t "<> ToString[FortranForm[Last[AddBlocks[[i,j]]]]]<>"\t # \n"];
j++;];
i++;];


WriteString[lh,"Block SPhenoInput # SPheno specific input\n"];
WriteString[lh,"1 \t -1 # error level\n"];
WriteString[lh,"2 \t 1 # SPA conventions\n"];
WriteString[lh,"11 \t 0 # calculate branching ratios\n"];
WriteString[lh,"12 \t 1.0000000E-04 # write only branching ratios \n"];
WriteString[lh,"34 \t 1.00000000E-07 # write only branching ratios \n"];
WriteString[lh,"21 \t 0 # calculate cross section\n"];
Close[lh];
];


MakeSubNum[list_]:=Block[{temp},
temp=DeleteCases[list,{},10];
Return[Flatten[Table[Table[ToExpression[temp[[i,1]]]@@Drop[temp[[i,j]],-1]->Last[temp[[i,j]]],{j,2,Length[temp[[i]]]}],{i,1,Length[temp]}]]];
];

MakeSubNum2[list_]:=Block[{tempList},
tempList=DeleteCases[list,{},10];
Return[Flatten[Table[Table[tempList[[i,1]]@@tempList[[i,2,j,1]]->tempList[[i,2,j,2]],{j,1,Length[tempList[[i,2]]]}],{i,1,Length[tempList]}]]];
];

PrintOutMassTable[file_]:=Block[{i,temp},
temp=FindValue["MASS",None,LesHouchesInput,1];
op=OpenWrite[file];
For[i=1,i<=Length[temp],
WriteString[op,ToString[Abs[N[temp[[i,2]],1]]]<>"\n"];
i++;];
Close[op];
];
